package com.junikarp.qbank.mock;

import com.junikarp.qbank.bookmark.domain.Bookmark;
import com.junikarp.qbank.question.domain.Question;
import com.junikarp.qbank.question.service.port.QuestionRepository;
import com.junikarp.qbank.user.domain.User;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeQuestionRepository implements QuestionRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Question> data = Collections.synchronizedList(new ArrayList<>());
    private final FakeBookmarkRepository fakeBookmarkRepository;

    public FakeQuestionRepository(FakeBookmarkRepository fakeBookmarkRepository) {
        this.fakeBookmarkRepository = fakeBookmarkRepository;
    }

    public void addBookmark(User user, Question question) {
        Bookmark bookmark = Bookmark.builder()
                .user(user)
                .question(question)
                .build();
        fakeBookmarkRepository.save(bookmark);
    }


    @Override
    public Question save(Question question) {
        if (question.getId() == null || question.getId() == 0) {
            Question newQuestion = Question.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .question(question.getQuestion())
                    .explanation(question.getExplanation())
                    .choices(question.getChoices())
                    .build();
            data.add(newQuestion);
            return newQuestion;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), question.getId()));
            data.add(question);
            return question;
        }
    }

    @Override
    public List<Question> findAll() {
        return data;
    }

    @Override
    public List<Question> findBookmarkedQuestionsByUserId(Long userId) {
        List<Question> questionList = fakeBookmarkRepository.getData().stream()
                .filter(bookmark -> bookmark.getUser().getId().equals(userId))
                .map(Bookmark::getQuestion)
                .toList();
        return data.stream()
                .filter(questionList::contains)
                .collect(Collectors.toList());
    }

}
